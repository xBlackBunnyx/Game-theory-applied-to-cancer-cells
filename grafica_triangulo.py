# -*- coding: utf-8 -*-
"""Grafica_triangulo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ee6jGZ4qrZSSgTZKdus6q6FKmxzo1N6S
"""

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
import numpy as np
import math

##########################################
# Code that does the triangle and print it
##########################################

# define the projection to triangular coordinates
cos30 = np.cos(30. / 360. * 2. * np.pi)
sin30 = np.sin(30. / 360. * 2. * np.pi)
proj = np.array(
    [[-cos30,  cos30, 0.],
     [-sin30, -sin30, 1.]])


# define the vertices and edges of the simplex
trianglepoints = np.hstack([np.identity(3), np.array([[1.], [0.], [0.]])])
triangleline = np.dot(proj, trianglepoints)


# display simplex labels
def etiquetasverticestriangulo(vert_labels, fontsize):
    ax.annotate(
        vert_labels[0],
        xy=(0, 0),
        xycoords="axes fraction",
        ha="right",
        va="top",
        fontsize=fontsize,
        color="blue",
    )
    ax.annotate(
        vert_labels[1],
        xy=(1, 0),
        xycoords="axes fraction",
        ha="left",
        va="top",
        fontsize=fontsize,
        color="green",
    )
    ax.annotate(
        vert_labels[2],
        xy=(0.5, 1),
        xycoords="axes fraction",
        ha="center",
        va="bottom",
        fontsize=fontsize,
        color="red",
    )

# plot the simplex edges
def dibujaejestriangulo():
    ax.plot(
        triangleline[0],
        triangleline[1],
        clip_on=False,
        color="black",
        zorder=3,
        linewidth=0.5
    )


# Draw the triangle
def dibujatriangulo():
    global gs
    global ax
    n_cols, n_rows = 1, 1
    # create the subplot grid
    gs = gridspec.GridSpec(n_rows, n_cols, hspace=0.2, wspace=0.3)
    gsize = (6 * n_cols, 6 * n_rows)

    # set the size of the figure
    size = (6 * n_cols, 6 * n_rows)
    fig = plt.figure(figsize=size)
    fontsz = 18 - n_cols

    gs = gridspec.GridSpec(1, 1, hspace=0.2, wspace=0.3)
    ax = fig.add_subplot(gs[0])
    ax.axis('off')

    dibujaejestriangulo()
    etiquetasverticestriangulo(["$A^{++}$", "$A^{+-}$", "$A^{--}$"], fontsz)


#Create the matrix with uniform points, div by side
def trama_de_puntos(div):
    puntos = []
    for z in range(div+1): #from 0 to div
        for x in range(div-z+1):
            puntos.append([x/div, 1-(z+x)/div, z/div])
    return puntos


#Find out the derivative of x according to the P matrix
def derivadaP(x, t):
    Px = np.matmul(P, x)
    xtPx = np.matmul(x, Px)
    dxdt = np.multiply(x, Px - xtPx)
    return dxdt

#Find out the derivative of x according to the P matrix and Q matrix
def derivadaQ(x, t):
    RP = np.multiply(R, P)
    Rx = np.matmul(R,x)
    iRx = 1/np.matmul(R,x)
    iRxM = np.column_stack((iRx, iRx, iRx))
    Q = np.multiply(RP, iRxM)
    Qx = np.matmul(Q, x)
    xtQx = np.matmul(x, Qx)
    dxdt = np.multiply(x, Qx - xtQx)
    return dxdt


#Print the points into the triangle and the direction
def dibujarpuntosyderivadas(x, tipoderivada, longitudflecha, dibujapuntos, normalizado):
  #tipoderivada: derivadaP, derivadaQ
  for i in range(len(x)):
    xy0 = np.dot(proj, x[i]) #Inicial point of the vector (in 2D, the triangle)
    xy = np.dot(proj, x[i] + tipoderivada(x[i],0)) #final point of the vector in 2D
    dx = xy[0] - xy0[0]
    dy = xy[1] - xy0[1]
    if normalizado:
        #norma = math.sqrt(dx*dx + dy*dy)/longitudflecha
        norma = np.linalg.norm(np.array((dx,dy)))/longitudflecha #Normalize the arrow
    else:
        norma = 1
    ax.arrow(xy0[0], xy0[1], dx/norma, dy/norma,
             head_width=0.02, color='grey') #Draw the arrow
    if dibujapuntos:
        ax.scatter(xy0[0], xy0[1], color="red", s=10, marker="o", zorder=3)

"""## Ejemplo primero
Solo matriz P
"""

#Payoff matrix
P = np.array([[1, 0.6, 0.7],
              [0.95, 0.9, 0.7],
              [1.2, 1.1, 0.8]])

nn = 15  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)
'''
dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaP, 0.8/nn, True, True)
'''
#con los vectores no normalizados y sin puntos
dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaP, 0.8/nn, False, False)

"""## Ejemplo segundo, con matriz de interacción R
R = todo 1
"""

#Payoff matrix
P = np.array([[1, 0.6, 0.7],
              [0.95, 0.9, 0.7],
              [1.2, 1.1, 0.8]])

#Interaction matrix
R = np.array([[1, 1, 1],
              [1, 1, 1],
              [1, 1, 1]])

nn = 15  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, False) #1º Bool, print scatter
                                                            #2º Bool, normalize

"""# Tercer ejemplo con matriz de interacción R
R = todo 1 menos r31 = 0.01, r32 = 0.1 y r33 = 100
"""

#Payoff matrix
P = np.array([[1, 0.6, 0.7],
              [0.95, 0.9, 0.7],
              [1.2, 1.1, 0.8]])

#Interaction matrix
R = np.array([[1, 1, 1],
              [1, 1, 1],
              [0.01, 0.1, 100]])

nn = 15  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)
dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, False)

nn = 35  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)
dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, False)

"""Así (poniendo un `nn` grande) se ve bien las tres zonas (cuencas de atracción de cada vértice, que parece que todos son equilibrios)

# Cuarto ejemplo con otra matriz P y R
P = [[1, 0.6, 0.4],
     [1.2, 0.8, 0.4],
     [1.2, 1, 0.6]])

R = todo 1 menos r23 = 0.1 y r33 = 10
"""

#Payoff matrix
P = np.array([[1, 0.6, 0.4],
              [1.2, 0.8, 0.4],
              [1.2, 1, 0.6]])

#Interaction matrix
R = np.array([[1, 1, 1],
              [1, 1, 0.1],
              [1, 1, 10]])


nn = 15  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, False)

"""# Quinto ejemplo con la P anterior y otra R
R = todo 1 menos r12 = 10, r23 = 0.1 y r33 = 10
"""

#Payoff matrix
P = np.array([[1, 0.6, 0.4],
              [1.2, 0.8, 0.4],
              [1.2, 1, 0.6]])

#Interaction matrix
R = np.array([[1, 10, 1],
              [1, 1, 0.1],
              [1, 1, 10]])

nn = 15  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, False)

"""#Tumor tubular"""

#Payoff matrix
P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])

#Interaction matrix
R = np.array([[0.4, 2.6, 6.63],
              [2.6, 5.98, 1.73],
              [4.84, 4.5, 0.83]])

nn = 30  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, True)

"""#Tumor Disperso"""

#Payoff matrix
P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])


#Interaction matrix
R = np.array([[1.2, 2.53, 7.04],
              [1.91, 6.4, 2.7],
              [4.7, 5.21, 3.04]])

nn = 30  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, True)

"""#Tumor Trabecular"""

#Payoff matrix
P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])


#Interaction matrix
R = np.array([[0.74, 1.63, 7.04],
              [2.5, 6.6, 2.15],
              [5.6, 3.1, 1.12]])

nn = 30  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, True)

"""#Tumor sólido"""

#Payoff matrix
P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])


#Interaction matrix
R = np.array([[1.1, 2.4, 7.7],
              [0.85, 6.7, 1.63],
              [6.7, 3.43, 3.4]])

nn = 30 #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, True)

"""#Tumor no estructural"""

#Payoff matrix
P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])


#Interaction matrix
R = np.array([[1.5, 2.2, 7.3],
              [1.6, 6.42, 2.2],
              [5.51, 2.62, 2.8]])

nn = 30  #number of points on each side of the triangle in the grid
x = trama_de_puntos(nn)

dibujatriangulo()
dibujarpuntosyderivadas(x, derivadaQ, 0.8/nn, False, True)

"""Ejemplo series temporales y trayectria en el triángulo

"""

###Función sin tener en cuenta la matriz de interacción
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import functools

#Matriz de pagos
P = np.array([[1, 2, 3],
              [2, 1, 4],
              [3, 5, 1]])

#Ecuación del replicador
def bucles(x,t):

    F = np.array([0., 0., 0.]) #iniciamos el contador para que se acumulen los valores
    for i in range(0,len(x)):
        #Bucle que multiplica todas las x por los valores de P para obtener la fitness
        for j in range(0,len(x)): #Este bucle recorre las columnas de la matriz
            F[i] += x[j] * P[i][j] #+= Acumula los valores, j recorre las columnas e i las filas

    M = 0 #Inicializamos la variable
    for i in range(0,len(x)): #Bucle que calcula $$ E(x) = \int_{-\infty}^{\infty}  xf(x)dx $la fitness media
        M += F[i] * x[i] #Acumula los valores para que se sumen las multiplicaciones

    for i in range(0,len(x)): #Bucle que calcula la derivada respecto al tiempo
        aux = F - M #Resta de la fitness menos la fitness media
        dxdt[i] = aux[i] * x[i]

    return dxdt #Lo ponemos aquí para que se haga el vector entero

#Gráfica del replicator
x = np.array([0.7, 0.2, 0.1])
dxdt = np.array([0., 0., 0.]) #Inicializamos la variable
dxdt = bucles(x,0)
t = np.linspace(0, 100, 100)
sol = odeint(bucles, x, t)
plt.plot(t, sol[:, 0], 'b', label='x1(t)')
plt.plot(t, sol[:, 1], 'g', label='x2(t)')
plt.plot(t, sol[:, 2], 'r', label='x3(t)')
plt.legend(loc='best')
plt.xlabel('tiempo')
plt.grid()
plt.show()

#.sol
trayectriangulo = np.dot(proj, sol.T)
#trayectriangulo
dibujatriangulo()
ax.plot(trayectriangulo[0],trayectriangulo[1] )

ax.scatter(trayectriangulo[0],trayectriangulo[1] )

sol.T

###Pruebas de bucles 3
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import functools

P = np.array([[1, 0.8, 0.6],
              [0.8, 0.7, 0.5],
              [0.7, 0.8, 0.5]])

#Interaction matrix
R = np.array([[0.4, 2.6, 6.63],
              [2.6, 5.98, 1.73],
              [4.84, 4.5, 0.83]])


def derivadaQ(x, t):
    RP = np.multiply(R, P)
    Rx = np.matmul(R,x)
    iRx = 1/np.matmul(R,x)
    iRxM = np.column_stack((iRx, iRx, iRx))
    Q = np.multiply(RP, iRxM)
    Qx = np.matmul(Q, x)
    xtQx = np.matmul(x.T, Qx)
    dxdt = np.multiply(x, Qx - xtQx)
    return dxdt


x = np.array([0.2, 0.4, 0.4])
t2 = np.linspace(0, 50, 50)
sol = odeint(derivadaP, x, t2)
plt.plot(t2, sol[:, 0], 'b', label='$A^{++}$(t)')
plt.plot(t2, sol[:, 1], 'g', label='$A^{+-}$(t)')
plt.plot(t2, sol[:, 2], 'r', label='$A^{--}$(t)')
plt.legend(loc='best')
plt.xlabel('tiempo')
plt.grid()
plt.show()

trayectriangulo = np.dot(proj, sol.T)
#trayectriangulo
dibujatriangulo()
ax.plot(trayectriangulo[0],trayectriangulo[1] )
#ax.scatter(trayectriangulo[0],trayectriangulo[1] )

plt.plot(trayectriangulo[0], trayectriangulo[1])
plt.show()